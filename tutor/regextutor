===============================================================================
= W e l c o m e   t o   t h e   V I M   R e g e x   T u t o r  -  Version 0.1 =
===============================================================================

  Vim is a very powerful editor with a very powerful search and replace
  system based on Regular Expressions. This tutor is designed to describe
  enough of those features that you will be able to more powerfully use
  Vim as an all-purpose editor.

  The approximate time required to complete the tutor is 30 minutes,
  depending upon how much time is spent with experimentation.

  ATTENTION:~
  The commands in the lessons will modify the text.  Make a copy of this
  file to practise on (if you started "vimregextutor" this is already a
  copy).

  It is important to remember that this tutor is set up to teach by use.
  That means that you need to execute the commands to learn them
  properly.  If you only read the text, you will forget the commands!

  If you haven't already completed the vimtutor, it is highly recommended
  that you do so first before attempting this tutorial.

  Occasional references to the Vim documentation are made throughout this
  tutorial. Such entries look like this: |'ignorecase'|. To open those
  entries, type (in normal mode - so press <ESCAPE> to leave insert mode
  first)  :help  followed by the exact entry. In this case, you would
  type:  :help 'ignorecase'

  What the Heck is a Regular Expression Anyway?~

  I'm sure you are familiar with the use of "wildcard" characters for
  pattern matching. For example, if you want to find all the text files
  in a directory, you search for "*.txt", knowing that the asterisk is
  interpreted as a wildcard that can match any sequence of characters.
  Regular expressions are just an elaborate extension of this capability.

  When manipulating text, it is frequently necessary to locate strings
  that match complex patterns. Regular expressions were invented to
  describe such patterns. Thus, a regular expression is just a shorthand
  code for a pattern. For example, the pattern  \w\+  is a concise way to
  say "match any non-null strings of alphanumeric characters". Vim
  provides a rich and powerful regular expression vocabulary with which
  you can readily and efficiently search and replace text.

  A good way to learn the arcane syntax of regular expressions is by
  starting with examples and then experimenting with your own creations.
  This tutorial introduces the basics of regular expressions, giving many
  common examples. The additional Vim plugin, regexcoach, can be used to
  try out the examples and to experiment with your own regular
  expressions.

  Let's get started!

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  Lesson 1.1: Searching for Elvis~

  Suppose you spend all your free time scanning documents looking for evidence
  that Elvis is still alive. You could search with the following regular
  expression:

  =========================================================================
  *1* : Find  elvis

    /elvis
  =========================================================================

  This is a perfectly valid regular expression that searches for an exact
  sequence of characters. In Vim, you can set the |'ignorecase'| option
  to ignore the case of characters, so this expression will match
  "Elvis", "ELVIS", or "eLvIs". Unfortunately, it will also match the
  last five letters of the word "pelvis".

  Your Turn~

  1. Make sure you have search highlighting enabled:  :set hlsearch

  2. Go to the line below marked --->

  3. type  /elvis  <ENTER>

  4. Confirm that the letters "elvis" are highlighted

--->  a) Rare are the sightings of elves, as are those of elvis himself.
      b) The pelvis of elvis was seldom still.

  NOTE: You can use  n  to move to the next match and  :nohl  to clear
        the search highlight.

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  Lesson 1.2: Limiting the search to a whole word~

  Did you notice how the word "pelvis" is partially matched with the
  search  /elvis  ? We can improve the expression as follows:

  =========================================================================
  *2* : Find  elvis  as a whole word

    /\<elvis\>
  =========================================================================

  Now things are getting a little more interesting. The  \<  is a special code
  that means, "match the position at the beginning of any word". Likewise,  \>
  means "match the position at the end of any word". This expression will only
  match complete words spelled "elvis" with any combination of lower case or
  capital letters (if |'ignorecase'| is enabled).

  Your Turn~

  1. Go to the line below marked --->

  2. type  /\<elvis\>  <ENTER>

  3. Confirm that only the word "elvis" (and not "pelvis") is highlighted

--->  a) Rare are the sightings of elves, as are those of elvis himself.
      b) The pelvis of elvis was seldom still.

  Did you notice how the word "pelvis" is now NOT matched with this
  enhanced regex?

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  Lesson 1.3: Searching for everything between two words~

  Suppose you want to find all lines in which the word "elvis" is followed by
  the word "alive." The period or dot  .  is a special code that matches any
  character other than a newline. The asterisk  *  means repeat the previous
  term as many times as necessary to guarantee a match. Thus,  .*  means
  "match any number of characters other than newline". It is now a simple
  matter to build an expression that means 'search for the word "elvis"
  followed anywhere thereafter on the same line by the word "alive"'.

  =========================================================================
  *3* : Find  elvis  followed by anything and then followed by  alive

    /\<elvis\>.*\<alive\>
  =========================================================================

  With just a few special characters we are beginning to build powerful
  regular expressions and they are already becoming hard for we humans to
  read.

  Your Turn~

  1. Go to the line below marked --->

  2. type  /\<elvis\>.*\<alive\>  <ENTER>

  3. Confirm that everything between "elvis" and "alive" is highlighted

--->  a) Rare are the sightings of elvis, more so those of him being alive.


~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  Lesson 2.1: Determining the Validity of Phone Numbers~

  Suppose you're editing a file which contains seven-digit phone numbers
  and you want to verify that the phone numbers are in the correct format,
  "xxx-xxxx", where each "x" is a digit. The following expression will
  search through text looking for such a string:

  =========================================================================
  *4* : Find  seven-digit phone number

    /\<\d\d\d-\d\d\d\d
  =========================================================================

  Your Turn~

  1. Go to the line below marked --->

  2. type  /\<\d\d\d-\d\d\d\d  <ENTER>

  3. Confirm that the seven-digit phone number is highlighted

--->  a) 123-4567

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  Lesson 2.2: Specifying repetition more concisely~

  Each  \d  means "match any single digit". The "-" has no special
  meaning and is interpreted literally, matching a hyphen. To avoid the
  annoying repetition, we can use a shorthand notation that means the
  same thing:

  =========================================================================
  *5a* : Find  seven-digit phone number  (more concisely)

    /\<\d\{3\}-\d\{4\}
  =========================================================================

  Your Turn~

  1. Go to the line below marked --->

  2. type  /\<\d\{3\}-\d\{4\}  <ENTER>

  3. Confirm that the seven-digit phone number is highlighted

--->  a) 123-4567

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  Lesson 2.3: It's Magic~

  The  \{3\}  following the  \d  means "repeat the preceding character
  three times". The  {  and  }  in that expression need to be escaped
  with  \  which can quickly become annoying for large expressions. Vim
  uses the  \m   regex pattern to enable |'magic'| mode, which helps to
  reduce the amount of  \  escaping needed in some patterns.
  Additionally, Vim also provides the  \v  pattern to enable "very magic"
  mode, even further reducing the need to escape certain elements.
  Using magic, the previous pattern becomes:

  =========================================================================
  *5b* : Find  seven-digit phone number  (using magic for better
       readability)

    /\m\<\d\{3}-\d\{4}
  =========================================================================

  OR, with very magic:

  =========================================================================
  *5c* : Find  seven-digit phone number  (using very magic for even
       better readability)

     /\v<\d{3}-\d{4}
  =========================================================================

  Your Turn~

  1. Go to the line below marked --->

  2. type  /\v<\d{3}-\d{4}  <ENTER>

  3. Confirm that the seven-digit phone number is highlighted

--->  a) 123-4567

  Next, we'll learn how to test this expression in regexcoach.


~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  Lesson 3.1: Regex Coach~

  Pending  (is it *actually* called regexcoach?)

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  Lesson 4.1: Special Characters:  *~

  You should get to know a few characters with special meaning. You already
  met  \<  .  *  and  \d . To match any whitespace characters, like
  spaces, tabs, and newlines, use  \s  . Similarly,  \w  matches any
  alphanumeric character.

  Let's try a few more examples:

  =========================================================================
  *6* : Find  words that start with the letter a

    /\<a\w*\>
  =========================================================================

  Your Turn~

  1. Go to the line below marked --->

  2. type  /\<a\w*\>  <ENTER>

  3. Confirm that all of the words starting with "a" are highlighted

--->  a) an apple a day keeps the aardvarks away

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  Lesson 4.2: Special Characters:  \+~

  This works by searching for the beginning of a word  \<  , then the letter
  "a", then any number of repetitions of alphanumeric characters  \w*  , then
  the end of a word  \> .

  =========================================================================
  *7* : Find  repeated strings of digits

    /\d\+
  =========================================================================

  Here, the  \+  is similar to  *  , except it requires at least one
  repetition.

  Your Turn~

  1. Go to the line below marked --->

  2. type  /\d\+  <ENTER>

  3. Confirm that all of the digits and only the digits are highlighted

--->  a) 1234 5678 900,000 1.23 13:45

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  Lesson 4.3: Six Letter Words~

  =========================================================================
  *8* : Find  six letter words

    /\v<\w{6}>
  =========================================================================

  Your Turn~

  1. Go to the line below marked --->

  2. Type  /\v<\w{6}>  <ENTER>

  3. Confirm that the word "attend" is highlighted

--->  a) Happy times and fine edits attend on thee.

  Try these in regexcoach and start experimenting by inventing your own
  expressions. See |pattern-overview|, |ordinary-atom|, and
  |character-classes| for Vim's special regular expression characters.

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  Lesson 4.4: In the beginning~

  The special characters  ^  and  $  are used when looking for something that
  must start at the beginning of the text and end at the end of the text,
  respectively.
  This is especially useful for validating input in which the entire text must
  match a pattern. For example, to validate a seven-digit phone number, you
  might use:

  =========================================================================
  *9* : Find  a seven-digit phone number on a line by itself

    /^\v\d{3}-\d{4}$
  =========================================================================

  This is the same as example [|5|], but anchored to the whole line,
  with nothing else before or after the matched text. This start of line
  character must be placed at the start of the regex pattern, otherwise it
  will represent a literal "^". The special character \_^  matches a newline
  at any position in the regex.

--

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  Lesson 4.5: Escaped characters~

  A problem occurs if you actually want to match one of the special
  characters, like  ^  or  $  . Use the backslash to remove the special
  meaning. Thus,  \^  ,  \.  , and  \\  , match the literal characters "^",
  ".", and "\", respectively.

--

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  Lesson 4.6: Repetitions~

  You've seen that  \{3\}  and  *  can be used to indicate repetition of a
  single character. Later, you'll see how the same syntax can be used to
  repeat entire subexpressions. There are several other ways to specify a
  repetition, as shown in |pattern-overview|.

  Some Examples:

  =========================================================================
  *10* : Find  all five and six letter words

     /\v<\w{5,6}>
  =========================================================================

  =========================================================================
  *11* : Find  ten digit phone numbers

     /\v\<\d{3}\s\d{3}-\d{4}
  =========================================================================

  =========================================================================
  *12* : Find  Social Security Number

     /\v\d{3}-\d{2}-\d{4}
  =========================================================================

  =========================================================================
  *13* : Find  The first word in the line

     /^\w*
  =========================================================================

--

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  Lesson 4.8: Character Classes~

  It is simple to find alphanumerics, digits, and whitespace, but what if we
  want to find anything from some other set of characters? This is easily done
  by listing the desired characters within square brackets. Thus, "[aeiou]"
  matches any vowel and "[.?!]" matches the punctuation at the end of a
  sentence. In this example, notice that the "." And "?" lose their special
  meanings within square brackets and are interpreted literally. We can also
  specify a range of characters, so "[a-z0-9]" means, "match any lowercase
  letter of the alphabet, or any digit".

  Let's try a more complicated expression that searches for telephone numbers.

  =========================================================================
  *14* : Find  A ten digit phone number

     /\v\(?\d{3}[) ]\s?\d{3}[- ]\d{4}
  =========================================================================

  This expression will find phone numbers in several formats, like "(800)
  325-3535" or "650 555 1212". The "\(?" searches for zero or one left
  parentheses, "[) ]" searches for a right parenthesis or a space. The "\s?"
  searches for zero or one whitespace characters. Unfortunately, it will also
  find cases like "650) 555-1212" in which the parenthesis is not balanced.
  Below, you'll see how to use alternatives to eliminate this problem.

  Your Turn~

  1. Go to the line below marked --->

  2. type  /\v\(?\d{3}[) ]\s?\d{3}[- ]\d{4}      <ENTER>

  3. Confirm that all of the phone numbers are highlighted

--->  a) (800) 325-3535
--->  b) 650 555 1212
--->  c) 650) 555-1212     (NOTE: Example of a false positive)

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  Lesson 4.9: Negation~

  Sometimes we need to search for a character that is NOT a member of an
  easily defined class of characters. The following table shows how this can
  be specified:

    \W         Match any character that is NOT alphanumeric

    \S         Match any character that is NOT whitespace

    \D         Match any character that is NOT a digit

    [^x]       Match any character that is NOT x

    [^aeiou]   Match any character that is NOT one of the characters aeiou

  =========================================================================
  *15* : Find  All strings that do not contain whitespace characters

     /\S\+
  =========================================================================

  Later, we'll see how to use "lookahead" and "lookbehind" to search for the
  absence of more complex patterns.

--

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  Lesson 4.10: Alternatives~

  To select between several alternatives, allowing a match if either one is
  satisfied, use the pipe "|" symbol to separate the alternatives. For
  example, Zip Codes come in two flavors, one with 5 digits, the other with 9
  digits and a hyphen. We can find either with this expression:

  =========================================================================
  *16* : Find  Nine and five digit Zip Codes

     /\v<\d{5}-\d{4}>|<\d{5}>
  =========================================================================

--

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  Lesson 4.11: Escaped characters~

  When using alternatives, the order is important since the matching algorithm
  will attempt to match the leftmost alternative first. If the order is
  reversed in this example, the expression will only find the 5 digit Zip
  Codes and fail to find the 9 digit ones. We can use alternatives to improve
  the expression for ten digit phone numbers, allowing the area code to appear
  either delimited by whitespace or parenthesis:

  =========================================================================
  *17* : Find  Ten digit phone numbers, a better way

     /\v(\(\d{3}\)|\d{3})\s?\d{3}[- ]\d{4}
  =========================================================================

--

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Grouping

Parentheses may be used to delimit a subexpression to allow repetition or other special treatment. For example:

18. (\d{1,3}\.){3}\d{1,3} A simple IP address finder

The first part of the expression searches for a one to three digit number followed by a literal period "\.". This is enclosed in parentheses and repeated three times using the "{3}" quantifier, followed by the same expression without the trailing period.

Unfortunately, this example allows IP addresses with arbitrary one, two, or three digit numbers separated by periods even though a valid IP address cannot have numbers larger than 255. It would be nice to arithmetically compare a captured number N to enforce N<256, but this is not possible with regular expressions alone. The next example tests various alternatives based on the starting digits to guarantee the limited range of numbers by pattern matching. This shows that an expression can become cumbersome even when looking for a pattern that is simple to describe.

19. ((2[0-4]\d|25[0-5]|[01]?\d\d?)\.){3}(2[0-4]\d|25[0-5]|[01]?\d\d?) IP finder

Expresso Analyzer View



Figure 2. Expresso's analyzer view showing example 17

Expresso has a feature that diagrams expressions in a Tree structure, explaining what each piece means. When debugging an expression, this can help zoom in on the part that is causing trouble. Try this by selecting example (17) and then using the Analyze button. Select nodes in the tree and expand them to explore the structure of this regular expression as shown in the figure. After highlighting a node, you can also use the Partial Match or Exclude Match buttons to run a match using just the highlighted portion of the regular expression or using the regular expression with the highlighted portion excluded.

When subexpressions are grouped with parentheses, the text that matches the subexpression is available for further processing in a computer program or within the regular expression itself. By default, groups are numbered sequentially as encountered in reading from left to right, starting with 1. This automatic numbering can be seen in Expresso's skeleton view or in the results shown after a successful match.

A "backreference" is used to search for a recurrence of previously matched text that has been captured by a group. For example, "\1" means, "match the text that was captured by group 1". Here is an example:

20. \b(\w+)\b\s*\1\b Find repeated words

This works by capturing a string of at least one alphanumeric character within group 1 "(\w+)", but only if it begins and ends a word. It then looks for any amount of whitespace "\s*" followed by a repetition of the captured text "\1" ending at the end of a word.

It is possible to override the automatic numbering of groups by specifying an explicit name or number. In the above example, instead of writing the group as "(\w+)", we can write it as "(?<Word>\w+)" to name this capture group "Word". A backreference to this group is written "\k<Word>". Try this example:

21. \b(?<Word>\w+)\b\s*\k<Word>\b Capture repeated word in a named group

Test this in Expresso and expand the match results to see the contents of the named group.

Using parentheses, there are many special purpose syntax elements available. Some of the most common are summarized in this table:


Captures

(exp)

Match exp and capture it in an automatically numbered group

(?<name>exp)

Match exp and capture it in a group named name

(?:exp)

Match exp, but do not capture it

Lookarounds

(?=exp)

Match any position preceding a suffix exp

(?<=exp)

Match any position following a prefix exp

(?!exp)

Match any position after which the suffix exp is not found

(?<!exp)

Match any position before which the prefix exp is not found

Comment

(?#comment)

Comment


Table 4. Commonly used Group Constructs

We've already talked about the first two. The third "(?:exp)" does not alter the matching behavior, it just doesn't capture it in a named or numbered group like the first two.

Positive Lookaround

The next four are so-called lookahead or lookbehind assertions. They look for things that go before or after the current match without including them in the match. It is important to understand that these expressions match a position like "^" or "\b" and never match any text. For this reason, they are known as "zero-width assertions". They are best illustrated by example:

"(?=exp)" is the "zero-width positive lookahead assertion". It matches a position in the text that precedes a given suffix, but doesn't include the suffix in the match:

22. \b\w+(?=ing\b) The beginning of words ending with "ing"

"(?<=exp)" is the "zero-width positive lookbehind assertion". It matches the position following a prefix, but doesn't include the prefix in the match:

23. (?<=\bre)\w+\b The end of words starting with "re"

Here is an example that could be used repeatedly to insert commas into numbers in groups of three digits:

24. (?<=\d)\d{3}\b Three digits at the end of a word, preceded by a digit

Here is an example that looks for both a prefix and a suffix:

25. (?<=\s)\w+(?=\s) Alphanumeric strings bounded by whitespace

Negative Lookaround

Earlier, I showed how to search for a character that is not a specific character or the member of a character class. What if we simply want to verify that a character is not present, but don't want to match anything? For example, what if we are searching for words in which the letter "q" is not followed by the letter "u"? We could try:

26. \b\w*q[^u]\w*\b Words with "q" followed by NOT "u"

Run the example and you will see that it fails when "q" is the last letter of a word, as in "Iraq". This is because "[^q]" always matches a character. If "q" is the last character of the word, it will match the whitespace character that follows, so in the example the expression ends up matching two whole words. Negative lookaround solves this problem because it matches a position and does not consume any text. As with positive lookaround, it can also be used to match the position of an arbitrarily complex subexpression, rather than just a single character. We can now do a better job:

27. \b\w*q(?!u)\w*\b Search for words with "q" not followed by "u"

We used the "zero-width negative lookahead assertion", "(?!exp)", which succeeds only if the suffix "exp" is not present. Here is another example:

28. \d{3}(?!\d) Three digits not followed by another digit

Similarly, we can use "(?<!exp)", the "zero-width negative lookbehind assertion", to search for a position in the text at which the prefix "exp" is not present:

29. (?<![a-z ])\w{7} Strings of 7 alphanumerics not preceded by a letter or space

Here is one more example using lookaround:

30. (?<=<(\w+)>).*(?=<\/\1>) Text between HTML tags

This searches for an HTML tag using lookbehind and the corresponding closing tag using lookahead, thus capturing the intervening text but excluding both tags.

Comments please

Another use of parentheses is to include comments using the "(?#comment)" syntax. A better method is to set the "Ignore Pattern Whitespace" option, which allows whitespace to be inserted in the expression and then ignored when the expression is used. With this option set, anything following a number sign "#" at the end of each line of text is ignored. For example, we can format the preceding example like this:

31. Text between HTML tags, with comments

(?<= # Search for a prefix, but exclude it
<(\w+)> # Match a tag of alphanumerics within angle brackets
) # End the prefix

.* # Match any text

(?= # Search for a suffix, but exclude it
<\/\1> # Match the previously captured tag preceded by "/"
) # End the suffix

Greedy and Lazy

When a regular expression has a quantifier that can accept a range of repetitions (like ".*"), the normal behavior is to match as many characters as possible. Consider the following regular expression:

32. a.*b The longest string starting with a and ending with b

If this is used to search the string "aabab", it will match the entire string "aabab". This is called "greedy" matching. Sometimes, we prefer "lazy" matching in which a match using the minimum number of repetitions is found. All the quantifiers in Table 2 can be turned into "lazy" quantifiers by adding a question mark "?". Thus "*?" means "match any number of repetitions, but use the smallest number of repetitions that still leads to a successful match". Now let's try the lazy version of example (32):

33. a.*?b The shortest string starting with a and ending with b

If we apply this to the same string "aabab" it will first match "aab" and then "ab".


*?

Repeat any number of times, but as few as possible

+?

Repeat one or more times, but as few as possible

??

Repeat zero or one time, but as few as possible

{n,m}?

Repeat at least n, but no more than m times, but as few as possible

{n,}?

Repeat at least n times, but as few as possible


Table 5. Lazy quantifiers

What did we leave out?

I've described a rich set of elements with which to begin building regular expressions; but I left out a few things that are summarized in the following table. Many of these are illustrated with additional examples in the project file. The example number is shown in the left-hand column of this table.


#

Syntax

Description

\a

Bell character

\b

Normally a word boundary, but within a character class it means backspace

\t

Tab

34

\r

Carriage return

\v

Vertical tab

\f

Form feed

35

\n

New line

\e

Escape

36

\nnn

Character whose ASCII octal code is nnn

37

\xnn

Character whose hexadecimal code is nn

38

\unnnn

Character whose Unicode is nnnn

39

\cN

Control N character, for example carriage return (Ctrl-M) is \cM

40

\A

Beginning of a string (like ^ but does not depend on the multiline option)

41

\Z

End of string or before \n at end of string (ignores multiline)

\z

End of string (ignores multiline)

42

\G

Beginning of the current search

43

\p{name}

Any character from the Unicode class named name, for example \p{IsGreek}

(?>exp)

Greedy subexpression, also known as a non-backtracking subexpression. This is matched only once and then does not participate in backtracking.

44

(?<x>-<y>exp) or (?-<y>exp)

Balancing group. This is complicated but powerful. It allows named capture groups to be manipulated on a push down/pop up stack and can be used, for example, to search for matching parentheses, which is otherwise not possible with regular expressions. See the example in the project file.

45

(?im-nsx:exp)

Change the regular expression options for the subexpression exp

46

(?im-nsx)

Change the regular expression options for the rest of the enclosing group

(?(exp)yes|no)

The subexpression exp is treated as a zero-width positive lookahead. If it matches at this point, the subexpression yes becomes the next match, otherwise no is used.

(?(exp)yes)

Same as above but with an empty no expression

(?(name)yes|no)

This is the same syntax as the preceding case. If name is a valid group name, the yes expression is matched if the named group had a successful match, otherwise the no expression is matched.

47

(?(name)yes)

Same as above but with an empty no expression


Table 6. Everything we left out. The left-hand column shows the number of an example in the project file that illustrates this construct.



~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

  This concludes the Vim Regex Tutor.  It was intended to give a brief
  overview of regular expressions in the Vim editor - just enough to allow you
  to start exploring the wonderful and powerful world of regexes on your own.
  It is far from complete as Vim has many many more regex features.  To learn
  more about regexes in Vim, see  |'pattern.txt'|

  If you want to read a book, I suggest the latest edition of:

    Mastering Regular Expressions, by Jeffrey Friedl.

  This tutorial is a rework by Barry Arthur of the original  .Net version by
  Jim Hollenhorst at:

    http://www.codeproject.com/KB/dotnet/regextutorial.aspx

  The layout is based on the original  vimtutor  by Michael C. Pierce and
  Robert K. Ware.

  Licencensed under the same terms as Vim itself.

  Send mistakes and suggestions to barry.arthur@gmail.com

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

# vim:tw=78:ts=8:ft=help:norl:noro:hlsearch:ignorecase
